Stats =& Type {
    health : public Integer()
    weight : public Integer()
    strength : public Integer()
    damage : public Integer()
    defense : public Integer()
    aoe : public Integer()
    heal : public Integer()
    knockback : public Integer()
    initiative : public Integer()
    impact_element : public String()
    break_element : public String()
    break_turns : public Integer()
    break_count : public Integer()
    
    _Ctor : public Function () {}
    _Ctor : public Function ( d : Dictionary ) {
        this.health = d.health
        this.weight = d.weight
        this.strength = d.strength
        this.damage = d.damage
        this.defense = d.defense
        this.aoe = d.aoe
        this.heal = d.heal
        this.knockback = d.knockback
        this.initiative = d.initiative
        this.impact_element = d.impact_element
        this.break_element = d.break_element
        this.break_turns = d.break_turns
        this.break_count = d.break_count
    }
}

Skill =& Type {
    cooldown : public Integer(0)
    usable : public String(always)
    child : public String()

    _Ctor : public Function ( d : Dictionary ) {
        this.cooldown = ( if( d.contains_key(cooldown) ) { d.cooldown } else {0} )
        this.usable = ( if( d.contains_key(usable) ) { d.usable } else {always} )
        this.child = ( if( d.contains_key(child) ) { d.child } else {""} )
    }
}

CpPhysicality =& Type {
    position : mutable Vector3D()
    angle : mutable Real()
    frame : mutable String(stand)
    
    get_2d_position : public Function() {
        right =& graphics.get_resolution().x
        bottom =& graphics.get_resolution().y
        horizon =& (0.65 * bottom).to_integer()
        margin =& bottom - horizon

        return Vector2D(this.position.x * right, this.position.y * margin + horizon - this.position.z * margin).to_integer_vector2d()
    }
    get_2d_position_shadow : public Function() {
        right =& graphics.get_resolution().x
        bottom =& graphics.get_resolution().y
        horizon =& (0.65 * bottom).to_integer()
        margin =& bottom - horizon
        
        return Vector2D(this.position.x * right, (this.position.y * margin + horizon)).to_integer_vector2d()
    }
}

CpVulnerable =& Type {
    health : mutable Integer()
}

CpBreakable =& Type {
    break_count : mutable Integer()
    break_turns_remaining : mutable Integer()
}

CpAllegiance =& Type {
    team : mutable String()
}

CpCharacter =& Type {
    name : String()
    color : Color()
    images : Dictionary()
    scale : Real()
    imageHeightAdjust : Real()
    stats : Stats()
    skills : Dictionary()
    
    _Ctor : public Function ( key : String, config : Dictionary ) {
        
        this.name = config.name
        this.color = colors[config.color]
        this.scale = config.scale
        this.imageHeightAdjust = config.imageHeightAdjust

        this.images = {
            stand : if(config.images.contains_key(stand)) {assets[config.images.stand]} else {nil},
            lift : if(config.images.contains_key(lift)) {assets[config.images.lift]} else {nil},
            impact : if(config.images.contains_key(impact)) {assets[config.images.impact]} else {nil},
            break_stand : if(config.images.contains_key(break_stand)) {assets[config.images.break_stand]} else {nil},
            break_impact : if(config.images.contains_key(break_impact)) {assets[config.images.break_impact]} else {nil}
        }

        this.stats = Stats( config )
        this.skills = Dictionary()
    }
    
    instantiate : public Function[Entity] ( sim : Ecs, xyArray : Array, team : String ) {
        entity =& sim."instantiate"(bouncer)
        entity.add_component( this )
        spawnLocation =& Vector3D( xyArray[0],  xyArray[1], 0 )
        entity.add_component( CpAllegiance { "team" : team } )
        entity.add_component( CpPhysicality { position : spawnLocation } )
        entity.add_component( CpVulnerable { health : this.stats.health } )
        entity.add_component( CpBreakable {} )
        entity.add_component( CpInitiative {} )
        return entity
    }
    
    get_jump_range : public Function() {
        return this.stats.strength.to_real() / this.stats.weight.to_real()
    }
    get_throw_range : public Function(obj : Entity) {
        return (this.stats.strength.to_real() + obj.CpCharacter.stats.strength.to_real()) / obj.CpCharacter.stats.weight.to_real()
    }
}

CpInitiative =& Type {
    initiative : mutable Real()
    hasMoved : mutable Boolean()
    
    roll : public mutating Function( char : CpCharacter ) {
        this.initiative = math.random_integer( 0, 100 ) + char.stats.initiative
    }
}