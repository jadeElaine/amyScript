frag{
    defines {
        uvcolor     "varying vec4 v_color; varying vec2 v_uv;"
        uvcolor_130 "in vec4 v_color; in vec2 v_uv;"
        
        normal      "varying vec3 v_pos, v_normal;"
        normal_130  "in vec3 v_pos, v_normal;"
        
        tangent     "varying vec3 v_tangent, v_binormal;"
        tangent_130 "in vec3 v_tangent, v_binormal;"
        
        paint       "uniform vec4 aki_paint;"
        
        light       "vec3 lightToVert; 
             float lightDistance; 
             float spotCosCutoff = -1.0;"

        texture     "uniform sampler2D %TEXTURE%;"
        
        si          "uniform float aki_si_colors[%COUNT%];"
        si_multi    "uniform vec4 aki_si_colors[%COUNT%];"

        finalColor  "vec4 finalColor = vec4(0.0,0.0,0.0,1.0);"
    }
    get_fragment_normal {
        func "vec3 get_fragment_normal()
            { 
                %BODY%
            }"
        
        body_notexture "return v_normal;"
        body_default "vec4 textureNorm = texture2D(%TEXTURE%,v_uv) * 2.0 - 1.0;
            return v_tangent * textureNorm.x +
                   v_binormal * textureNorm.y +
                   v_normal * textureNorm.z;"
        body_withcomponent "vec2 mapSize = %TEXTURESIZE%;
            %BUMP_LOOP%;\
            float dx = (t12-t11)/2.0 + (t13-t12)/2.0 +
                       (t22-t21)     + (t23-t22) +
                       (t32-t31)/2.0 + (t33-t32)/2.0;
            float dy = (t21-t11)/2.0 + (t31-t21)/2.0 +
                       (t22-t12)     + (t32-t22) +
                       (t23-t13)/2.0 + (t33-t23)/2.0;
            vec3 textureNorm = normalize(vec3(-dx, -dy, 1.0));
            return v_tangent * textureNorm.x +
                   v_binormal * textureNorm.y +
                   v_normal * textureNorm.z;"
                   
        texture_size       "vec2( 256.0, 256.0 )"
        texture_size_130   "textureSize(%TEXTURE%, 0)"
        bump_loop_element  "float t%I%%J% = texture2D( %TEXTURE%, v_uv + vec2(%X%.0/mapSize.x, %Y%.0/mapSize.y) ).%COMPONENT%;"
    }
    finalcolor {
        ambient_tail_component ".%COMPONENT%; finalColor.a = (gl_LightModel.ambient * gl_FrontMaterial.ambient).a"
        basic_tail_component ".%COMPONENT%"
        
        ambient "finalColor = texture2D(%TEXTURE%, v_uv)%TAIL%;"
        ambient_use_ambient_light "finalColor = (gl_LightModel.ambient * gl_FrontMaterial.ambient) * texture2D(%TEXTURE%, v_uv)%TAIL%;"
        
        paint "vec4 paint = texture2D(%TEXTURE%, v_uv);
            float paintMask = 1.0 - clamp(max(max(paint.r,paint.g),paint.b), 0.0, 1.0);"
        paint_component "float paintMask = 1.0 - texture2D(%TEXTURE%, v_uv)%TAIL%;"
        paint_apply "finalColor.r *= paintMask; finalColor.g *= paintMask; finalColor.b *= paintMask;"
        
        si_notexture  "vec4 siColor = vec4(1.0,1.0,1.0,0.0);"
        si            "vec4 siColor = texture2D(%TEXTURE%, v_uv)%TAIL%;"
        si_c          "vec4 siColor = texture2D(%TEXTURE%, v_uv)%TAIL% * aki_si_colors[0];"
        si_subdivided "vec4 siColor = vec4(0.0,0.0,0.0,1.0);
            for( int j=0; j<%SDY%; j++ )
            for( int i=0; i<%SDX%; i++ )
            {
                vec2 uvMod = vec2((v_uv.x+float(i)) / %SDX%.0, (v_uv.y+float(%SDY% - j - 1)) / %SDY%.0);
                vec4 tgtColor = vec4(1.0,1.0,1.0,1.0) * texture2D(%TEXTURE%, uvMod)%TAIL%;
                tgtColor.a = 0.0;
                siColor += tgtColor;
            }"
        si_subdivided_c "vec4 siColor = vec4(0.0,0.0,0.0,1.0);
            for( int j=0; j<%SDY%; j++ )
            for( int i=0; i<%SDX%; i++ )
            {
                vec2 uvMod = vec2((v_uv.x+float(i)) / %SDX%.0, (v_uv.y+float(%SDY% - j - 1)) / %SDY%.0);
                vec4 tgtColor = vec4(1.0,1.0,1.0,1.0) * texture2D(%TEXTURE%, uvMod)%TAIL% * aki_si_colors[i + j * %SDX%];
                tgtColor.a = 0.0;
                siColor += tgtColor;
            }"
        si_apply "finalColor += siColor * gl_FrontMaterial.emission;"
    }
}